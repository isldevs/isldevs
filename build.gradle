plugins {
    id('java')
    id('war')
    alias(libs.plugins.spring.boot)
    alias(libs.plugins.dependency.management)
    alias(libs.plugins.graalvm.native)
    alias(libs.plugins.flyway)
    alias(libs.plugins.versions)
    alias(libs.plugins.spotless)
}

import org.springframework.boot.gradle.plugin.SpringBootPlugin

dependencyManagement {
    imports {
        mavenBom(SpringBootPlugin.BOM_COORDINATES)
    }
}

group = 'com.base'

java {
    toolchain { languageVersion = JavaLanguageVersion.of(25) }
}

configurations {
    compileOnly { extendsFrom annotationProcessor }
    developmentOnly { extendsFrom runtimeOnly }
}

apply from: 'gradle/dependencies.gradle'

configurations.configureEach {
    resolutionStrategy {
        force 'org.apache.tomcat.embed:tomcat-embed-core:10.1.39'
        cacheChangingModulesFor 10, 'minutes'
        cacheDynamicVersionsFor 10, 'minutes'

        eachDependency { DependencyResolveDetails details ->
            if (details.requested.group == 'org.apache.logging.log4j' && details.requested.name.startsWith('log4j-')) {
                details.useVersion '2.24.3'
            }
        }
    }
}

def loadEnvironment() {
    def env = new Properties()
    def activeProfile = findProperty("spring.profiles.active") ?: "dev"

    def profilePropsFile = file("src/main/resources/application-${activeProfile}.properties")
    if (profilePropsFile.exists()) profilePropsFile.withInputStream { env.load(it) }

    def defaultPropsFile = file("src/main/resources/application.properties")
    if (defaultPropsFile.exists()) defaultPropsFile.withInputStream { stream ->
        def defaultProps = new Properties()
        defaultProps.load(stream)
        defaultProps.each { key, value -> if (!env.containsKey(key)) env.setProperty(key, value) }
    }

    def envFile = file(".env")
    if (envFile.exists()) envFile.withInputStream { env.load(it) }

    System.getenv().each { key, value ->
        if (key.startsWith('DB_') || key.startsWith('SPRING_')) env.setProperty(key, value)
    }

    return env
}

def activeProfile = findProperty("spring.profiles.active") ?: "dev"

sourceSets {
    main {
        java {
            srcDirs = ['src/main/java']
        }
        resources {
            srcDirs = ['src/main/resources']
        }
    }
    test {
        java {
            srcDirs = ['src/test/java']
        }
        resources {
            srcDirs = ['src/test/resources']
        }
    }
}

repositories {
    mavenCentral()
    maven { url = 'https://repo.spring.io/milestone/' }
    maven { url = uri("https://raw.githubusercontent.com/graalvm/native-build-tools/snapshots") }
    maven { url = 'https://download.eclipse.org/oomph/jdt/maven/' }
}

dependencyLocking {
    lockAllConfigurations()
    lockMode = (activeProfile == 'dev') ? LockMode.STRICT :  LockMode.LENIENT
}

graalvmNative {
    toolchainDetection = false
    binaries {
        main {
            imageName = project.name
            mainClass = "com.base.ISLDevsApplication"
            buildArgs.addAll([
                    '--verbose',
                    '--no-fallback',
                    '--enable-url-protocols=http,https',
                    '--enable-native-access=ALL-UNNAMED',
                    '--initialize-at-build-time=org.springframework.util.unit.DataSize',
                    '--report-unsupported-elements-at-runtime',
                    '--allow-incomplete-classpath',
                    '-H:+ReportExceptionStackTraces',
                    '-H:+AddAllCharsets',
                    '-H:EnableURLProtocols=http,https',
                    '-H:NativeLinkerOption=-z',
                    '-H:NativeLinkerOption=stack-size=2097152',
                    '-H:+StaticExecutableWithDynamicLibC'
            ])
        }
    }
}

dependencyUpdates {
    rejectVersionIf {
        isNonStable(it.candidate.version) && !isNonStable(it.currentVersion)
    }
    outputDir = "build/dependencyUpdates"
    reportfileName = "report"
    checkForGradleUpdate = true
    outputFormatter = "json"
}

static boolean isNonStable(String version) {
    def stableKeyword = ['RELEASE', 'FINAL', 'GA'].any { version.toUpperCase().contains(it) }
    def regex = /^[0-9,.v-]+(-r)?$/
    return !stableKeyword && !(version ==~ regex)
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.release = 25
    options.incremental = true
    options.fork = true
    options.failOnError = false
    options.forkOptions.jvmArgs = ['-Duser.language=en', '-Duser.country=US']
    options.compilerArgs += [
            "-parameters",
            "-Xlint:-unchecked",
            "-Xlint:-deprecation",
            "--enable-preview",
            "-Amapstruct.suppressGeneratorTimestamp=true",
            "-Amapstruct.suppressGeneratorVersionInfoComment=true",
            "-Amapstruct.defaultComponentModel=spring",
            "-Amapstruct.verbose=false"
    ]
}

tasks.withType(JavaExec).configureEach {
    jvmArgs += ["--enable-preview"]
}

springBoot { mainClass = "com.base.ISLDevsApplication" }

bootRun {
    environment(loadEnvironment())
    jvmArgs = [
            "-Dspring.profiles.active=${activeProfile}",
            "-Dfile.encoding=UTF-8",
            "-XX:+HeapDumpOnOutOfMemoryError",
            "--add-opens",
            "java.base/sun.misc=ALL-UNNAMED",
            "--enable-preview",
    ]
    systemProperties = System.properties
    sourceResources sourceSets.main
    if (activeProfile == 'dev') classpath = sourceSets.main.runtimeClasspath + configurations.developmentOnly
}

tasks.named("bootJar") {
    archiveBaseName = "isldevs"
    archiveClassifier = "standalone"
}
tasks.named("war") {
    archiveBaseName = "isldevs"
    archiveClassifier = "deploy"
}
tasks.named("bootWar") { enabled = false }
tasks.named("jar") { enabled = false }

abstract class GenerateTestClasses extends DefaultTask {
    @InputDirectory
    abstract DirectoryProperty getMainJavaDir()

    @OutputDirectory
    abstract DirectoryProperty getTestJavaDir()

    @TaskAction
    void generate() {
        def mainJavaDirFile = mainJavaDir.get().asFile
        def testJavaDirFile = testJavaDir.get().asFile

        mainJavaDirFile.eachFileRecurse { File sourceFile ->
            if (sourceFile.name.endsWith(".java") &&
                    !sourceFile.name.endsWith("Test.java") &&
                    !sourceFile.name.endsWith("Tests.java") &&
                    !sourceFile.name.endsWith("Application.java") &&
                    sourceFile.name != "package-info.java") {

                def relativePath = mainJavaDirFile.toPath().relativize(sourceFile.parentFile.toPath())
                def packageName = relativePath.toString().replace(File.separator, '.')

                def testFile = new File(testJavaDirFile,
                        relativePath.resolve(sourceFile.name.replace('.java', 'Tests.java')).toString()
                )

                if (!testFile.exists()) {
                    testFile.parentFile.mkdirs()
                    testFile.text = """\
                        |package ${packageName};
                        |
                        |import org.junit.jupiter.api.Test;
                        |import static org.junit.jupiter.api.Assertions.*;
                        |
                        |class ${sourceFile.name.replace('.java', '')}Tests {
                        |
                        |    @Test
                        |    void contextLoads() {
                        |    }
                        |}
                        |""".stripMargin()
                }
            }
        }
    }
}

tasks.register('generateTestClasses', GenerateTestClasses) {
    group = 'Verification'
    description = 'Generates test class scaffolds'
    mainJavaDir.set(layout.projectDirectory.dir("src/main/java"))
    testJavaDir.set(layout.projectDirectory.dir("src/test/java"))
}

spotless {
    java {
        eclipse().configFile(file('src/main/resources/java-code-style.xml'))
        target 'src/main/java/**/*.java'
        licenseHeaderFile 'LICENSE', '(package|import|public|class|interface|enum)'
        targetExclude([
                '**/build/**', '**/aotSources/**', '**/generated/**', '**/target/**', '**/out/**', '**/bin/**',
                '**/aot*/**', '**/*__Generated.java', '**/org/springframework/**', '**/*.properties',
                '**/*.yml', '**/*.yaml', '**/*.json', '**/*.xml', '**/*.sql', '**/*.p12', '**/*.jks',
                '**/*.keystore', '**/*.dev', '**/*.prod', '**/*.sh', '**/*.bat', '**/*.jar',
                '**/*.war', '**/*.md', '**/*.txt', '**/*.html', '**/*.private', '**/*.public',
                '**/gradlew*', '**/gradle/wrapper/**', '**/*Tests.java', '**/*Test.java',
                '**/.dev', '**/.prod', '**/.env', '**/aot*/**', '**/*__Generated.java', '**/org/springframework/**'
        ])
        removeUnusedImports()
    }
}

tasks.named("spotlessApply") {
    group = 'formatting'
    description = 'Apply code formatting'
}

tasks.named("spotlessCheck") {
    group = 'verification'
    description = 'Check code formatting and Apply LICENSE Header'
}

tasks.named('generateTestClasses') {
    dependsOn tasks.named('spotlessApply')
}

tasks.named('compileJava') {
    dependsOn tasks.named('spotlessApply')
}

tasks.named('compileTestJava') {
    dependsOn tasks.named('generateTestClasses')
}

tasks.matching { it.name.contains("Aot") || it.name.contains("aot") }.configureEach {
    enabled = false
}

tasks.named('processAot') {
    dependsOn tasks.named('compileJava')
}

tasks.named('test', Test) {
    environment(loadEnvironment())
    useJUnitPlatform()
    jvmArgs += ["--enable-preview"]
    systemProperty 'spring.profiles.active', 'test'
    maxHeapSize = '2G'
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat = "full"
    }
    if (project.hasProperty('skipIntegrationTests') &&
            Boolean.parseBoolean(project.property('skipIntegrationTests'))) {
        exclude('**/test/**')
    }
}

tasks.named('build') { dependsOn 'test', 'spotlessCheck', 'generateTestClasses' }
tasks.named('assemble') { dependsOn war, bootJar }