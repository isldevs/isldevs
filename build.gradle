plugins {
    id 'java'
    id 'war'
    id 'com.diffplug.spotless'
    id 'org.springframework.boot'
    id 'io.spring.dependency-management'
    id 'org.graalvm.buildtools.native'
    id 'org.flywaydb.flyway'
    id 'com.github.hierynomus.license'
    id 'com.github.ben-manes.versions'
}

group = 'com.base'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

repositories {
    mavenCentral()
    maven { url = 'https://repo.spring.io/milestone' }
}

configurations.configureEach {
    resolutionStrategy {
        force 'org.apache.tomcat.embed:tomcat-embed-core:10.1.39'
        cacheChangingModulesFor 10, 'minutes'
    }
}

apply from: 'gradle/dependencies.gradle'

dependencyLocking {
    lockAllConfigurations()
}

def env = new Properties()
def activeProfile = findProperty("spring.profiles.active") ?: "dev"
def envFiles = [
        file("src/main/resources/config/.${activeProfile}"),
        file(".env")
]

envFiles.each { envFile ->
    if (envFile.exists()) {
        envFile.withInputStream { env.load(it) }
        println "Loaded environment from: ${envFile}"
    }
}

dependencyUpdates {
    rejectVersionIf {
        isNonStable(it.candidate.version)
    }
    outputDir = "build/dependencyUpdates"
    reportfileName = "report"
}

compileJava {
    def isDev = activeProfile in 'dev'
    options.compilerArgs += [
            '-Amapstruct.suppressGeneratorTimestamp=true',
            '-Amapstruct.suppressGeneratorVersionInfoComment=true',
            '-Amapstruct.defaultComponentModel=spring',
            '-Amapstruct.verbose=' + (isDev)
    ]
}

static boolean isNonStable(String version) {
    def stableKeyword = ['RELEASE', 'FINAL', 'GA'].any { it -> version.toUpperCase().contains(it) }
    def regex = /^[0-9,.v-]+(-r)?$/
    return !stableKeyword && !(version ==~ regex)
}

flyway {
    url = env.getProperty("DB_URL") ?: System.getenv("DB_URL")
    user = env.getProperty("DB_USERNAME") ?: System.getenv("DB_USERNAME")
    password = env.getProperty("DB_PASSWORD") ?: System.getenv("DB_PASSWORD")
    locations = ['classpath:db/migration']
    baselineOnMigrate = true
    validateMigrationNaming = true
}

bootRun {
    environment env
    jvmArgs = [
            "-Dspring.profiles.active=${activeProfile}",
            "-Dfile.encoding=UTF-8",
            "-XX:+HeapDumpOnOutOfMemoryError"
    ]
    systemProperties = System.properties
}

bootWar {
    archiveClassifier = 'boot'
    archiveFileName = "${project.name}.war"
}

bootJar {
    archiveFileName = "${project.name}.jar"
    launchScript()
}

sourceSets {
    main {
        output.resourcesDir = file("$buildDir/classes/java/main")
        java {
            if (activeProfile != "dev") {
                exclude '**/TomcatSSLConfig.java'
            }
        }
    }
    test {
        output.resourcesDir = file("$buildDir/classes/java/test")
        java {
            if (activeProfile != "dev") {
                exclude '**/test/**'
            }
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    options.fork = true
    options.encoding = 'UTF-8'
    options.compilerArgs += "--enable-preview"
    options.forkOptions.jvmArgs.addAll(['-Duser.language=en', '-Duser.country=US'])
    options.compilerArgs += [
            '-parameters',
            '-Xlint:-unchecked',
            '-Xlint:-deprecation',
            '--enable-preview'
    ]
}

tasks.withType(JavaExec).configureEach {
    jvmArgs += "--enable-preview"
}

tasks.withType(Test).configureEach {
    jvmArgs += "--enable-preview"
}

license {
    header = rootProject.file('LICENSE_HEADER')
    strictCheck = true
    skipExistingHeaders = true
    mapping {
        java = 'SLASHSTAR_STYLE'
    }
    excludes([
            '**/build/**',
            '**/generated/**',
            '**/target/**',
            '**/out/**',
            '**/bin/**',
            '**/aot*/**',
            '**/*__Generated.java',
            '**/org/springframework/**',
            '**/*.properties',
            '**/*.yml',
            '**/*.yaml',
            '**/*.json',
            '**/*.xml',
            '**/*.sql',
            '**/*.p12',
            '**/*.jks',
            '**/*.keystore',
            '**/*.dev',
            '**/*.prod',
            '**/*.sh',
            '**/*.bat',
            '**/*.jar',
            '**/*.war',
            '**/*.md',
            '**/*.txt',
            '**/*.html',
            '**/*.private',
            '**/*.public',
            '**/gradlew*',
            '**/gradle/wrapper/**',
            '**/*Tests.java',
            '**/*Test.java',
            '**/.dev',
            '**/.prod',
            '**/.env',
            '**/aot*/**',
            '**/*__Generated.java',
            '**/org/springframework/**'
    ])
}

tasks.named('licenseMain') {
    mustRunAfter tasks.named('compileAotJava')
}

tasks.named('licenseTest') {
    mustRunAfter tasks.named('compileAotJava')
}

licenseFormatTest {
    dependsOn 'generateTestClasses'
}

tasks.named('licenseAot') {
    enabled = false
}

tasks.named('licenseAotTest') {
    enabled = false
}

licenseTest {
    dependsOn 'generateTestClasses'
}

processTestAot {
    logging.captureStandardOutput(LogLevel.ERROR)
}

processAot {
    enabled = false
}

tasks.named('processResources') {
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

tasks.register('generateTestClasses') {
    group = 'Verification'
    description = 'Generates test class scaffolds'

    inputs.dir(layout.projectDirectory.dir('src/main/java'))
    outputs.dir(layout.projectDirectory.dir('src/test/java'))

    doLast {
        def mainJavaDir = file('src/main/java')

        fileTree(mainJavaDir).matching {
            include '**/*.java'
            exclude '**/*Test.java', '**/*Tests.java', '**/package-info.java', '**/*Application.java'
        }.each { sourceFile ->
            def testFile = file(sourceFile.path
                    .replace('main/java', 'test/java')
                    .replace('.java', 'Tests.java'))

            if (!testFile.exists()) {
                testFile.parentFile.mkdirs()

                // Correct package name calculation
                def packageName = mainJavaDir.toPath()
                        .relativize(sourceFile.parentFile.toPath())
                        .toString()
                        .replace(File.separator, '.')

                testFile.text = """\
                    |package ${packageName};
                    |
                    |import org.junit.jupiter.api.Test;
                    |import static org.junit.jupiter.api.Assertions.*;
                    |
                    |class ${sourceFile.name.replace('.java', '')}Tests {
                    |
                    |    @Test
                    |    void contextLoads() {
                    |    }
                    |}
                    |""".stripMargin()
            }
        }
    }
}

compileTestJava {
    dependsOn(tasks.named('generateTestClasses'))
}

tasks.withType(JavaCompile).configureEach {
    options.compilerArgs += [
            '-Xlint:-unchecked',
            '-Xlint:-deprecation',
            '-Xlint:-processing'
    ]
    options.encoding = 'UTF-8'
}

tasks.named('assemble') {
    dependsOn bootWar, bootJar
}

war {
    enabled = true
    archiveClassifier = ''
    classpath = classpath.filter { file ->
        !file.name.contains('spring-boot-starter-tomcat') &&
                !file.name.contains('spring-boot-starter-jetty') &&
                !file.name.contains('spring-boot-starter-undertow')
    }
}

tasks.withType(AbstractArchiveTask).configureEach {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}

tasks.named('test', Test) {
    useJUnitPlatform()
    systemProperty 'spring.profiles.active', 'test'
    maxHeapSize = '1G'
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat = "full"
    }
    filter {
        includeTestsMatching "*Test"
        includeTestsMatching "*Tests"
    }
    dependsOn(tasks.named('generateTestClasses'))
    if (project.hasProperty('skipIntegrationTests') && Boolean.parseBoolean(project.property('skipIntegrationTests'))) {
        exclude('**/test/**')
    }
}