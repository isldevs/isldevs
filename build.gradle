plugins {
    id 'java'
    id 'war'
    id 'com.diffplug.spotless' version '7.2.1'
    id 'org.springframework.boot' version '3.5.4'
    id 'io.spring.dependency-management' version '1.1.7'
    id 'org.graalvm.buildtools.native' version '0.10.5'
    id "org.flywaydb.flyway" version "9.22.3"
    id "com.github.hierynomus.license" version "0.16.1"
    id 'com.github.ben-manes.versions' version '0.51.0'
}

group = 'com.base'
version = '0.0.1-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
    sourceCompatibility = JavaVersion.VERSION_21
    targetCompatibility = JavaVersion.VERSION_21
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
    developmentOnly {
        extendsFrom runtimeOnly
    }
}

configurations.configureEach {
    resolutionStrategy {
        force 'org.apache.tomcat.embed:tomcat-embed-core:10.1.39'
        cacheChangingModulesFor 10, 'minutes'
        cacheDynamicVersionsFor 10, 'minutes'
    }
}

repositories {
    mavenCentral()
    maven { url = 'https://repo.spring.io/milestone/' }
    maven { url = uri("https://raw.githubusercontent.com/graalvm/native-build-tools/snapshots") }
}

apply from: 'gradle/dependencies.gradle'

dependencyLocking {
    lockAllConfigurations()
    lockMode = LockMode.STRICT
}

graalvmNative {
    toolchainDetection = false
    binaries {
        main {
            imageName = "${project.name}"
            mainClass = "com.base.ISLDevsApplication"
            buildArgs.addAll([
                    '--verbose',
                    '--no-fallback',
                    '--enable-url-protocols=http,https',
                    '--initialize-at-build-time=org.springframework.util.unit.DataSize',
                    '--report-unsupported-elements-at-runtime',
                    '--allow-incomplete-classpath',
                    '-H:+ReportExceptionStackTraces',
                    '-H:+AddAllCharsets',
                    '-H:EnableURLProtocols=http,https',
                    '-H:NativeLinkerOption=-z',
                    '-H:NativeLinkerOption=stack-size=2097152',
                    '-H:+StaticExecutableWithDynamicLibC'
            ])
        }
    }
}

def loadEnvironment() {
    def env = new Properties()
    def activeProfile = findProperty("spring.profiles.active") ?: "dev"
    def profilePropsFile = file("src/main/resources/application-${activeProfile}.properties")
    if (profilePropsFile.exists()) {
        profilePropsFile.withInputStream { stream ->
            env.load(stream)
        }
        logger.info("Loaded properties from: ${profilePropsFile.name}")
    }
    def defaultPropsFile = file("src/main/resources/application.properties")
    if (defaultPropsFile.exists()) {
        defaultPropsFile.withInputStream { stream ->
            def defaultProps = new Properties()
            defaultProps.load(stream)
            defaultProps.each { key, value ->
                if (!env.containsKey(key)) {
                    env.setProperty(key, value)
                }
            }
        }
        logger.info("Loaded properties from: ${defaultPropsFile.name}")
    }
    def envFile = file(".env")
    if (envFile.exists()) {
        envFile.withInputStream { stream ->
            env.load(stream)
        }
        logger.info("Loaded environment from: .env")
    }
    System.getenv().each { key, value ->
        if (key.startsWith('DB_') || key.startsWith('SPRING_')) {
            env.setProperty(key, value)
        }
    }

    return env
}

def env = loadEnvironment()
def activeProfile = findProperty("spring.profiles.active") ?: "dev"

dependencyUpdates {
    rejectVersionIf {
        isNonStable(it.candidate.version) && !isNonStable(it.currentVersion)
    }
    outputDir = "build/dependencyUpdates"
    reportfileName = "report"
    checkForGradleUpdate = true
    outputFormatter = "json"
}

static boolean isNonStable(String version) {
    def stableKeyword = ['RELEASE', 'FINAL', 'GA'].any { version.toUpperCase().contains(it) }
    def regex = /^[0-9,.v-]+(-r)?$/
    return !stableKeyword && !(version ==~ regex)
}

compileJava {
    def isDev = activeProfile in 'dev'
    options.compilerArgs += [
            '-Amapstruct.suppressGeneratorTimestamp=true',
            '-Amapstruct.suppressGeneratorVersionInfoComment=true',
            '-Amapstruct.defaultComponentModel=spring',
            '-Amapstruct.verbose=' + (isDev),
            '--enable-preview'
    ]
    options.encoding = 'UTF-8'
    options.fork = true
    options.forkOptions.jvmArgs = ['-Duser.language=en', '-Duser.country=US']
}

flyway {

    def propsFile = file("src/main/resources/application-${activeProfile}.properties")
    def properties = new Properties()

    if (propsFile.exists()) {
        propsFile.withInputStream { properties.load(it) }
    }

    url = properties.getProperty('spring.datasource.url') ?: env.getProperty('DB_URL') ?: System.getenv('DB_URL') ?: "jdbc:postgresql://localhost:5432/isl_devs"
    user = properties.getProperty('spring.datasource.username') ?: env.getProperty('DB_USERNAME') ?: System.getenv('DB_USERNAME') ?: "postgres"
    password = properties.getProperty('spring.datasource.password') ?: env.getProperty('DB_PASSWORD') ?: System.getenv('DB_PASSWORD') ?: "password"
    locations = ['classpath:db/migration']
    baselineOnMigrate = true
    validateMigrationNaming = true
    cleanDisabled = false
}

bootRun {
    environment env
    jvmArgs = [
            "-Dspring.profiles.active=${activeProfile}",
            "-Dfile.encoding=UTF-8",
            "-XX:+HeapDumpOnOutOfMemoryError",
            "--enable-preview"
    ]
    systemProperties = System.properties
    sourceResources sourceSets.main
    if (activeProfile == 'dev') {
        classpath = sourceSets.main.runtimeClasspath + configurations.developmentOnly
    }
}

bootWar {
    archiveClassifier = 'boot'
    archiveFileName = "${project.name}.war"
    manifest {
        attributes(
                'Implementation-Title': project.name,
                'Implementation-Version': project.version,
                'Built-By': System.getProperty('user.name'),
                'Built-JDK': System.getProperty('java.version'),
                'Build-Time': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                'Spring-Boot-Version': '3.5.4'
        )
    }
}

bootJar {
    archiveFileName = "${project.name}.jar"
    launchScript()
    manifest {
        attributes(
                'Implementation-Title': project.name,
                'Implementation-Version': project.version,
                'Built-By': System.getProperty('user.name'),
                'Built-JDK': System.getProperty('java.version'),
                'Build-Time': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ"),
                'Spring-Boot-Version': '3.5.4'
        )
    }
}

sourceSets {
    main {
        output.resourcesDir = file("$buildDir/classes/java/main")
        java {
            if (activeProfile != "dev") {
                exclude '**/TomcatSSLConfig.java'
            }
        }
    }
    test {
        output.resourcesDir = file("$buildDir/classes/java/test")
        java {
            if (activeProfile != "dev") {
                exclude '**/test/**'
            }
        }
    }
}

tasks.withType(JavaCompile).configureEach {
    options.fork = true
    options.encoding = 'UTF-8'
    options.compilerArgs += "--enable-preview"
    options.forkOptions.jvmArgs.addAll(['-Duser.language=en', '-Duser.country=US'])
    options.compilerArgs += [
            '-parameters',
            '-Xlint:unchecked',
            '-Xlint:deprecation',
            '--enable-preview',
            '-parameters',
            '-Amapstruct.suppressGeneratorTimestamp=true',
            '-Amapstruct.verbose=false'
    ]
}

tasks.withType(JavaExec).configureEach {
    jvmArgs += "--enable-preview"
}

tasks.withType(Test).configureEach {
    jvmArgs += "--enable-preview"
    useJUnitPlatform()
    systemProperty 'spring.profiles.active', 'test'
    maxHeapSize = '2G'
    maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1

    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat = "full"
        showExceptions = true
        showCauses = true
        showStackTraces = true
    }

    filter {
        includeTestsMatching "*Test"
        includeTestsMatching "*Tests"
    }
}

war {
    enabled = true
    archiveClassifier = ''
    classpath = classpath.filter { file ->
        !file.name.contains('spring-boot-starter-tomcat') &&
                !file.name.contains('spring-boot-starter-jetty') &&
                !file.name.contains('spring-boot-starter-undertow')
    }
}

tasks.named('assemble') {
    dependsOn bootWar, bootJar
}

tasks.named('build') {
    dependsOn 'test', 'spotlessCheck', 'licenseMain'
}

license {
    header = rootProject.file('LICENSE_HEADER')
    strictCheck = true
    skipExistingHeaders = true
    mapping {
        java = 'SLASHSTAR_STYLE'
    }
    excludes([
            '**/build/**',
            '**/generated/**',
            '**/target/**',
            '**/out/**',
            '**/bin/**',
            '**/aot*/**',
            '**/*__Generated.java',
            '**/org/springframework/**',
            '**/*.properties',
            '**/*.yml',
            '**/*.yaml',
            '**/*.json',
            '**/*.xml',
            '**/*.sql',
            '**/*.p12',
            '**/*.jks',
            '**/*.keystore',
            '**/*.dev',
            '**/*.prod',
            '**/*.sh',
            '**/*.bat',
            '**/*.jar',
            '**/*.war',
            '**/*.md',
            '**/*.txt',
            '**/*.html',
            '**/*.private',
            '**/*.public',
            '**/gradlew*',
            '**/gradle/wrapper/**',
            '**/*Tests.java',
            '**/*Test.java',
            '**/.dev',
            '**/.prod',
            '**/.env',
            '**/aot*/**',
            '**/*__Generated.java',
            '**/org/springframework/**'
    ])
}

tasks.named('licenseMain') {
    mustRunAfter tasks.named('compileAotJava')
}

tasks.named('licenseTest') {
    mustRunAfter tasks.named('compileAotJava')
}

licenseFormatTest {
    dependsOn 'generateTestClasses'
}

tasks.named('licenseAot') {
    enabled = false
}

tasks.named('licenseAotTest') {
    enabled = false
}

licenseTest {
    dependsOn 'generateTestClasses'
}

processTestAot {
    logging.captureStandardOutput(LogLevel.ERROR)
}

processAot {
    enabled = false
}

tasks.named('processResources') {
    duplicatesStrategy = DuplicatesStrategy.INCLUDE
}

tasks.register('generateTestClasses') {
    group = 'Verification'
    description = 'Generates test class scaffolds'

    inputs.dir(layout.projectDirectory.dir('src/main/java'))
    outputs.dir(layout.projectDirectory.dir('src/test/java'))

    doLast {
        def mainJavaDir = file('src/main/java')

        fileTree(mainJavaDir).matching {
            include '**/*.java'
            exclude '**/*Test.java', '**/*Tests.java', '**/package-info.java', '**/*Application.java'
        }.each { sourceFile ->
            def testFile = file(sourceFile.path
                    .replace('main/java', 'test/java')
                    .replace('.java', 'Tests.java'))

            if (!testFile.exists()) {
                testFile.parentFile.mkdirs()

                // Correct package name calculation
                def packageName = mainJavaDir.toPath()
                        .relativize(sourceFile.parentFile.toPath())
                        .toString()
                        .replace(File.separator, '.')

                testFile.text = """\
                    |package ${packageName};
                    |
                    |import org.junit.jupiter.api.Test;
                    |import static org.junit.jupiter.api.Assertions.*;
                    |
                    |class ${sourceFile.name.replace('.java', '')}Tests {
                    |
                    |    @Test
                    |    void contextLoads() {
                    |    }
                    |}
                    |""".stripMargin()
            }
        }
    }
}

compileTestJava {
    dependsOn(tasks.named('generateTestClasses'))
}

tasks.withType(JavaCompile).configureEach {
    options.compilerArgs += [
            '-Xlint:-unchecked',
            '-Xlint:-deprecation',
            '-Xlint:-processing'
    ]
    options.encoding = 'UTF-8'
}

tasks.withType(AbstractArchiveTask).configureEach {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}

tasks.named('test', Test) {
    useJUnitPlatform()
    systemProperty 'spring.profiles.active', 'test'
    maxHeapSize = '1G'
    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat = "full"
    }
    filter {
        includeTestsMatching "*Test"
        includeTestsMatching "*Tests"
    }
    dependsOn(tasks.named('generateTestClasses'))
    if (project.hasProperty('skipIntegrationTests') && Boolean.parseBoolean(project.property('skipIntegrationTests'))) {
        exclude('**/test/**')
    }
}